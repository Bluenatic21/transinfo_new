diff --git a/backend/email_utils.py b/backend/email_utils.py
index cb3a8df486381339178ba2b807f9acae9ac780fa..ce3b8cd5e9d3faa3111ad773b8a871ae56ed1768 100644
--- a/backend/email_utils.py
+++ b/backend/email_utils.py
@@ -17,84 +17,86 @@ def _bool(name: str, default: bool = False) -> bool:
     return str(v).strip().lower() in ("1", "true", "yes", "on")
 
 
 def _cfg():
     """
     Берём переменные окружения КАЖДЫЙ ВЫЗОВ,
     чтобы порядок импортов не ломал отправку.
     """
     # Гарантированно подтянем .env.local / .env,
     # даже если основной код не положил их в os.environ
     _ensure_env_loaded()
     transport = os.getenv("EMAIL_TRANSPORT", "smtp" if os.getenv(
         "SMTP_USER") else "console").lower()
     host = os.getenv("SMTP_HOST", "mail.transinfo.ge")
     port = int(os.getenv("SMTP_PORT", "587"))
     user = os.getenv("SMTP_USER", "") or ""
     pwd = os.getenv("SMTP_PASSWORD", "") or os.getenv("SMTP_PASS", "") or ""
     from_email = os.getenv("FROM_EMAIL", user or "noreply@transinfo.ge")
     use_tls = _bool("SMTP_USE_TLS", True)
     use_ssl = _bool("SMTP_USE_SSL", False)
     debug = 1 if _bool("SMTP_DEBUG", False) else 0
     return {"transport": transport, "host": host, "port": port, "user": user, "pwd": pwd,
             "from": from_email, "use_tls": use_tls, "use_ssl": use_ssl, "debug": debug}
 
 
-def _ensure_env_loaded() -> None:
+def _ensure_env_loaded() -> None:
     """
     Ленивая подгрузка .env.local / .env.
     Если python-dotenv есть — используем его.
     Если нет — простым парсером кладём пары KEY=VALUE в os.environ (не перезаписывая).
     """
-    base = Path(__file__).resolve().parent
-    for name in (".env.local", ".env"):
-        p = base / name
-        if not p.exists():
-            continue
-        # попробуем через python-dotenv
-        try:
-            from dotenv import load_dotenv  # type: ignore
-            load_dotenv(p, override=False)
-            return
-        except Exception:
-            pass
-        # fallback: ручной парсер
-        try:
-            for raw in p.read_text(encoding="utf-8").splitlines():
-                line = raw.strip()
-                if not line or line.startswith("#"):
-                    continue
-                if "=" not in line:
-                    continue
-                k, v = line.split("=", 1)
-                k = k.strip()
-                v = v.strip().strip('"').strip("'")
-                os.environ.setdefault(k, v)
-            return
-        except Exception:
-            # ничего не делаем — пусть дальше будут дефолты
-            return
+    base = Path(__file__).resolve().parent
+    roots = {base, base.parent}
+    filenames = (".env.local", ".env", ".env.production")
+
+    for root in roots:
+        for name in filenames:
+            p = root / name
+            if not p.exists():
+                continue
+            # попробуем через python-dotenv
+            try:
+                from dotenv import load_dotenv  # type: ignore
+                load_dotenv(p, override=False)
+                # не выходим: хотим считать все файлы с setdefault
+            except Exception:
+                # fallback: ручной парсер
+                try:
+                    for raw in p.read_text(encoding="utf-8").splitlines():
+                        line = raw.strip()
+                        if not line or line.startswith("#"):
+                            continue
+                        if "=" not in line:
+                            continue
+                        k, v = line.split("=", 1)
+                        k = k.strip()
+                        v = v.strip().strip('"').strip("'")
+                        os.environ.setdefault(k, v)
+                except Exception:
+                    # ничего не делаем — пусть дальше будут дефолты
+                    pass
 
 
 def _to_plain(html: str) -> str:
     # максимально простой fallback без внешних зависимостей
     import re
     text = re.sub(r"<br\s*/?>", "\n", html, flags=re.I)
     text = re.sub(r"<[^>]+>", "", text)
     return re.sub(r"\n{3,}", "\n\n", text).strip()
 
 
 def _build_message(from_email: str, to_email: str, subject: str, html_body: str) -> MIMEMultipart:
     msg = MIMEMultipart("alternative")
     msg["From"] = from_email
     msg["To"] = to_email
     msg["Subject"] = subject
     msg["Date"] = formatdate(localtime=True)
     msg["Message-ID"] = make_msgid(domain=from_email.split("@")[-1])
     # сначала plaintext, затем html — так рекомендуют SMTP-провайдеры
     msg.attach(MIMEText(_to_plain(html_body), "plain", "utf-8"))
     msg.attach(MIMEText(html_body, "html", "utf-8"))
     return msg
 
 
 def _ssl_context() -> ssl.SSLContext:
     # Нормальный безопасный контекст
