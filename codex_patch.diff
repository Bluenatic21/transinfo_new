diff --git a/frontend/src/app/components/TransportCompactCard.js b/frontend/src/app/components/TransportCompactCard.js
index 1c93e1364bb5a762fc7eb1b8991228ac8afe7821..a3ae155ed368e6c7a4ab92c1ea251de0b4437be6 100644
--- a/frontend/src/app/components/TransportCompactCard.js
+++ b/frontend/src/app/components/TransportCompactCard.js
@@ -332,67 +332,83 @@ export default function TransportCompactCard({
     // Автоскролл только по внешнему фокусу (isFocused)
     useEffect(() => {
         if (isFocused && cardRef && cardRef.current) {
             cardRef.current.scrollIntoView({ behavior: "smooth", block: "center" });
         }
     }, [isFocused]);
 
     // Красивая анимация подсветки при фокусе (isFocused)
     useEffect(() => {
         if (!isFocused || !cardRef.current) return;
         const node = cardRef.current;
         node.classList.add("flash-highlight");
         setTimeout(() => {
             node.classList.remove("flash-highlight");
         }, 1400);
     }, [isFocused]);
 
     // Автоскролл по ховеру (хук должен быть на верхнем уровне, а не в JSX)
     useEffect(() => {
         if (!enableHoverScroll) return;
         if (!hoveredItemId || hoveredItemId !== transport?.id) return;
         cardRef.current?.scrollIntoView({ behavior: "smooth", block: "center" });
     }, [hoveredItemId, enableHoverScroll, transport?.id]);
 
     // --- Компактный текст доступности ---
-    function parseDateDMY(str) {
-        if (!str) return null;
-        const s = String(str).trim();
-        const iso = s.match(/^(\d{4})-(\d{2})-(\d{2})(?:T.*)?$/);
-        if (iso) return `${iso[1]}-${iso[2]}-${iso[3]}`; // уже ISO
-        const parts = s.match(/^(\d{1,2})[./-](\d{1,2})[./-](\d{2,4})$/);
-        if (!parts) return s;
-        const [, d, m, y] = parts;
-        return `${String(y).padStart(4, "20")}-${String(m).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
-    }
-    function formatAvail(from, to) {
-        if (from && to && from !== to) {
-            return `${new Date(parseDateDMY(from)).toLocaleDateString(intl, { day: "2-digit", month: "2-digit", year: "2-digit" })} — ${new Date(parseDateDMY(to)).toLocaleDateString(intl, { day: "2-digit", month: "2-digit", year: "2-digit" })}`;
-        }
-        if (from) return new Date(parseDateDMY(from)).toLocaleDateString(intl, { day: "2-digit", month: "2-digit", year: "2-digit" });
-        return "—";
-    }
+    function parseDateDMY(str) {
+        if (!str) return null;
+        const s = String(str).trim();
+
+        // 1) Попробуем нативный парсер, он корректно понимает "MM/DD/YYYY" → Dec 3, 2025
+        const direct = new Date(s);
+        if (!isNaN(direct)) return direct;
+
+        // 2) ISO YYYY-MM-DD (с optional временем)
+        const iso = s.match(/^(\d{4})-(\d{2})-(\d{2})(?:T.*)?$/);
+        if (iso) return new Date(`${iso[1]}-${iso[2]}-${iso[3]}`);
+
+        // 3) dd.mm.yyyy / dd-mm-yyyy / dd/mm/yyyy
+        const parts = s.match(/^(\d{1,2})[./-](\d{1,2})[./-](\d{2,4})$/);
+        if (parts) {
+            const [, d, m, y] = parts;
+            return new Date(`${String(y).padStart(4, "0")}-${String(m).padStart(2, "0")}-${String(d).padStart(2, "0")}`);
+        }
+
+        return null;
+    }
+    function formatAvail(from, to) {
+        const render = (v) => {
+            const d = parseDateDMY(v);
+            return d ? d.toLocaleDateString(intl, { day: "2-digit", month: "2-digit", year: "2-digit" }) : "—";
+        };
+
+        if (from && to && from !== to) {
+            return `${render(from)} — ${render(to)}`;
+        }
+        if (from) return render(from);
+        return "—";
+    }
     const availText =
         transport?.mode === "постоянно"
             ? (transport?.regularity
                 ? `${t("availability.constant", "постоянно")} — ${localizeRegularity(transport.regularity)}`
                 : t("availability.constant", "постоянно"))
             : formatAvail(transport.ready_date_from, transport.ready_date_to);
 
     const metaItems = useMemo(() => {
         const items = [];
         if (transport.transport_kind) {
             items.push({
                 key: "kind",
                 content: (
                     <span
                         className={limited ? "pw-blur pw-noevents" : ""}
                         style={{ display: "inline-flex", alignItems: "center", gap: 6, color: "var(--compact-card-meta-accent)" }}
                     >
                         <FaTruck style={{ marginRight: 3, verticalAlign: -2 }} />
                         <span style={{ fontWeight: 700 }}>{findKindLabelByValue(transport.transport_kind)}</span>
                     </span>
                 ),
             });
         }
         items.push({
             key: "avail",
