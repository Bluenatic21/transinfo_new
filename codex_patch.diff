diff --git a/backend/main.py b/backend/main.py
index f99fb1de34b67fc87ffe549d5ba083dd7fe66a97..570ea5c017ac450b6f59d2202e557e70bed45f3c 100644
--- a/backend/main.py
+++ b/backend/main.py
@@ -3710,51 +3710,52 @@ def email_from_token(token):
     payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
     return payload.get("sub")
 
 
 @app.post("/profile/avatar")
 def upload_avatar(
     file: UploadFile = File(...),
     db: Session = Depends(get_db),
     authorization: str = Header(None),
 ):
     if not authorization or not authorization.startswith("Bearer "):
         raise HTTPException(401, "Not authenticated")
     token = authorization[7:]
     current_user = db.query(UserModel).filter(
         UserModel.email == email_from_token(token)).first()
     if not current_user:
         raise HTTPException(401, "User not found")
 
     # Только png или jpg!
     ext = os.path.splitext(file.filename)[-1].lower()
     if ext not in [".png", ".jpg", ".jpeg", ".doc", ".docx"]:
         raise HTTPException(400, "Только .png, .jpg, .doc, .docx файлы!")
 
     # Генерируем уникальное имя файла
     avatar_filename = f"avatars/{uuid4().hex}{ext}"
-    save_path = os.path.join("static", avatar_filename)
+    # Сохраняем аватар точно в той папке, которая раздаётся FastAPI через STATIC_DIR
+    save_path = os.path.join(STATIC_DIR, avatar_filename)
     os.makedirs(os.path.dirname(save_path), exist_ok=True)
 
     # Записываем файл правильно!
     contents = file.file.read()
     with open(save_path, "wb") as f:
         f.write(contents)
     if len(contents) < 100:  # На всякий случай, проверь размер
         raise HTTPException(400, "Файл слишком маленький или не картинка!")
 
     current_user.avatar = f"/static/{avatar_filename}"
     db.commit()
     db.refresh(current_user)
     return {"avatar": current_user.avatar}
 
 
 @app.patch("/profile", response_model=UserProfile)
 def update_profile(
     user_update: UserUpdate,
     db: Session = Depends(get_db),
     authorization: str = Header(None),  # <-- вот так!
 ):
     if not authorization or not authorization.startswith("Bearer "):
         raise HTTPException(401, "Not authenticated")
     token = authorization[7:]
     current_user = db.query(UserModel).filter(
