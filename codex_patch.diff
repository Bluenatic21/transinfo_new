diff --git a/backend/main.py b/backend/main.py
index 487ccb44cf4eac9e3849a09eeca8379cb9f66d4e..f4acfd9b12b39fad6ee6d31e74f4cc91b08e116e 100644
--- a/backend/main.py
+++ b/backend/main.py
@@ -3685,102 +3685,84 @@ def create_rating(
 
 
 @app.get("/profile/ratings/{user_id}", response_model=List[RatingSchema])
 def get_user_ratings(
     user_id: int,
     db: Session = Depends(get_db)
 ):
     return db.query(RatingModel).filter(RatingModel.user_id == user_id).order_by(RatingModel.created_at.desc()).all()
 
 
 @app.get("/users/{user_id}", response_model=UserProfile)
 def get_user_profile(user_id: int, db: Session = Depends(get_db)):
     user = db.query(UserModel).filter(UserModel.id == user_id).first()
     if not user:
         raise HTTPException(status_code=404, detail="User not found")
     return user
 
 
 @app.get("/users", response_model=List[UserOut])
 def get_all_users(db: Session = Depends(get_db), current_user: UserModel = Depends(get_current_user)):
     # Возвращаем всех пользователей, кроме текущего — доступно всем залогиненным
     users = db.query(UserModel).filter(UserModel.id != current_user.id).all()
     return users
 
 
-def email_from_token(token):
-    payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
-    return payload.get("sub")
-
-
 @app.post("/profile/avatar")
 def upload_avatar(
     file: UploadFile = File(...),
     db: Session = Depends(get_db),
-    authorization: str = Header(None),
+    current_user: UserModel = Depends(get_current_user),
 ):
-    if not authorization or not authorization.startswith("Bearer "):
-        raise HTTPException(401, "Not authenticated")
-    token = authorization[7:]
-    current_user = db.query(UserModel).filter(
-        UserModel.email == email_from_token(token)).first()
-    if not current_user:
-        raise HTTPException(401, "User not found")
-
     # Только png или jpg!
     ext = os.path.splitext(file.filename)[-1].lower()
     if ext not in [".png", ".jpg", ".jpeg", ".doc", ".docx"]:
         raise HTTPException(400, "Только .png, .jpg, .doc, .docx файлы!")
 
     # Генерируем уникальное имя файла
     avatar_filename = f"avatars/{uuid4().hex}{ext}"
     # Сохраняем именно в STATIC_DIR/avatars
     save_path = STATIC_DIR / avatar_filename
     save_path.parent.mkdir(parents=True, exist_ok=True)
 
     contents = file.file.read()
     save_path.write_bytes(contents)
     if len(contents) < 100:  # На всякий случай, проверь размер
         raise HTTPException(400, "Файл слишком маленький или не картинка!")
 
     current_user.avatar = f"/static/{avatar_filename}"
     db.commit()
     db.refresh(current_user)
     return {"avatar": current_user.avatar}
 
 
 @app.patch("/profile", response_model=UserProfile)
 def update_profile(
     user_update: UserUpdate,
     db: Session = Depends(get_db),
-    authorization: str = Header(None),  # <-- вот так!
+    current_user: UserModel = Depends(get_current_user),
 ):
-    if not authorization or not authorization.startswith("Bearer "):
-        raise HTTPException(401, "Not authenticated")
-    token = authorization[7:]
-    current_user = db.query(UserModel).filter(
-        UserModel.email == email_from_token(token)).first()
     for attr, value in user_update.dict(exclude_unset=True).items():
         setattr(current_user, attr, value)
     db.commit()
     db.refresh(current_user)
     return current_user
 
 
 @app.post("/profile/documents")
 def upload_documents(
     file: UploadFile = File(...),
     db: Session = Depends(get_db),
     current_user: UserModel = Depends(get_current_user)
 ):
     ext = os.path.splitext(file.filename)[-1]
     doc_filename = f"docs/{uuid4().hex}{ext}"
     save_path = os.path.join("static", doc_filename)
     os.makedirs(os.path.dirname(save_path), exist_ok=True)
     with open(save_path, "wb") as f:
         f.write(file.file.read())
 
     # Сохраняем ссылку на документ в профиле пользователя
     docs = current_user.docs_files or []
     docs.append(f"/static/{doc_filename}")
     current_user.docs_files = docs
     current_user.verification_status = "pending"
